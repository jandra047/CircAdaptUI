#ifndef BUFFER_H
#define BUFFER_H

#include <QMap>
#include <QString>
#include <QMutex>
#include <QObject>
#include "beatdata.h"

/*!
 *  @brief Holds data generated by running \ref ModelWrapper
 *
 *  Buffer receives the data generated by \ref ModelWrapper and stores it in \ref m_data.
 */
class Buffer : public QObject
{
    Q_OBJECT
public:
    Buffer();

    /*!
     * \brief Append data to the buffer
     * \param key Key of the data vector
     * \param value Value to append
     */
    void append(const QString& key, double value);

    /*!
     * \brief Get values from buffer
     * \param key Key of the data vector
     * \param dt Timespan of the data to get
     * \return
     */
    QVector<double> get(const QString& key, double dt);

    /*!
     * \brief Remove data from buffer
     *
     * This function is called after each update graphs phase to
     * clear data that has been plotted.
     * \param dt Timespan of the data to remove
     */
    void clear(double dt);

    /*!
     * \brief Get number of datapoints currenly present for each key stored in buffer.
     * \return Length of time vector.
     */
    int getLen() { QMutexLocker l(&mutex); return m_data["t"].size(); }

    void runAfterBeat();

public:
signals:
    void updateValueView(const QMap<QString, double> lastBeatData);

private:

    /*!
     * \brief Holds data plotted in CURRENT column.
     */
    QMap<QString, QVector<double>> m_data;

    /*!
     * \brief Storage for 2 last beats
     */
    QVector<BeatData*> m_beatData;

    /*!
     * \brief Holds data for the beat currently running.
     * When the beat is finished running (when ModelWrapper emits a signal) this data
     * is added to m_beatData.
     */
    QMap<QString, QVector<double>> m_currentBeatData;

    QMutex mutex;

};



#endif // BUFFER_H
